package provider

import (
	"context"
	"fmt"
	"strings"

	p "github.com/pulumi/pulumi-go-provider"
	"github.com/pulumi/pulumi-go-provider/infer"
	"github.com/pulumi/pulumi/sdk/v3/go/common/util/contract"

	"github.com/pulumi/pulumi-pulumiservice/provider/pkg/internal/pulumiapi"
	"github.com/pulumi/pulumi/sdk/v3/go/common/resource"
)

var (
	// Life-cycle participation
	_ infer.CustomCheck[WebhookInput]                  = (*Webhook)(nil)
	_ infer.CustomResource[WebhookInput, WebhookState] = (*Webhook)(nil)
	_ infer.CustomUpdate[WebhookInput, WebhookState]   = (*Webhook)(nil)
	_ infer.CustomRead[WebhookInput, WebhookState]     = (*Webhook)(nil)
	_ infer.CustomDelete[WebhookState]                 = (*Webhook)(nil)

	// Schema documentation
	_ infer.Annotated = (*Webhook)(nil)
	_ infer.Annotated = (*WebhookInput)(nil)
	_ infer.Annotated = (*WebhookState)(nil)
)

type Webhook struct{}

func (p *Webhook) Annotate(a infer.Annotator) {
	a.Describe(p, ` Pulumi Webhooks allow you to notify external services of events happening within your Pulumi organization or stack. For example, you can trigger a notification whenever a stack is updated. Whenever an event occurs, Pulumi will send an HTTP POST request to all registered webhooks. The webhook can then be used to emit some notification, start running integration tests, or even update additional stacks.

### Import

`+"Pulumi webhooks can be imported using the `id`, which for webhooks is `{org}/{project}/{stack}/{webhook-name}` e.g.,"+`

`+"```sh"+`
 $ pulumi import pulumiservice:index:Webhook my_webhook my-org/my-project/my-stack/4b0d0671
`+"```\n")
}

type WebhookInput struct {
	Active           bool             `pulumi:"active"`
	DisplayName      string           `pulumi:"displayName"`
	PayloadUrl       string           `pulumi:"payloadUrl"`
	Secret           *string          `pulumi:"secret,optional" provider:"secret"`
	OrganizationName string           `pulumi:"organizationName" provider:"replaceOnChanges"`
	ProjectName      *string          `pulumi:"projectName,optional" provider:"replaceOnChanges"`
	StackName        *string          `pulumi:"stackName,optional" provider:"replaceOnChanges"`
	Format           *string          `pulumi:"format,optional"` // TODO[FEAT]: Format should be an enum
	Filters          []WebhookFilters `pulumi:"filters,optional"`
}

func (p *WebhookInput) Annotate(a infer.Annotator) {
	a.Describe(&p.Active, "Indicates whether this webhook is enabled or not.")
	a.Describe(&p.DisplayName, "The friendly name displayed in the Pulumi Cloud.")
	a.Describe(&p.PayloadUrl, "URL to send request to.")
	a.Describe(&p.Secret, "Optional. secret used as the HMAC key. See "+
		"[webhook docs](https://www.pulumi.com/docs/intro/pulumi-service/webhooks/#headers) "+
		"for more information.")
	a.Describe(&p.OrganizationName, "Name of the organization.")
	a.Describe(&p.ProjectName, "Name of the project. Only needed if this is a stack webhook.")
	a.Describe(&p.StackName, "Name of the stack. Only needed if this is a stack webhook.")
	// TODO[INVESTAGATE]: This says format is oneOf(slack,raw), but the output description gives 4 options.
	//
	// Is that correct, you can set 2 with the API but 4 are available?
	a.Describe(&p.Format, "Format of the webhook payload. Can be either `raw` or `slack`. Defaults to `raw`.")
	a.SetDefault(&p.Format, "raw")
	a.Describe(&p.Filters, "Optional set of filters to apply to the webhook. See "+
		"[webhook docs](https://www.pulumi.com/docs/intro/pulumi-service/webhooks/#filters) "+
		"for more information.")
}

type WebhookState struct {
	WebhookInput

	Name   string `pulumi:"name"`
	Format string `pulumi:"format"`
}

func (p *WebhookState) Annotate(a infer.Annotator) {
	a.Describe(&p.Name, "Webhook identifier generated by Pulumi Cloud.")
	a.Describe(&p.Format, "Format of the webhook payload. Can be either `raw`, `slack`, `ms_teams` or `pulumi_deployments`. Defaults to `raw`.")
}

var _ infer.Enum[string] = WebhookFilters("")

type WebhookFilters string

func (WebhookFilters) Values() []infer.EnumValue[string] {
	return []infer.EnumValue[string]{
		{
			Value:       "stack_created",
			Description: "Trigger a webhook when a stack is created. Only valid for org webhooks.",
			Name:        "StackCreated",
		},
		{
			Value:       "stack_deleted",
			Description: "Trigger a webhook when a stack is deleted. Only valid for org webhooks.",
			Name:        "StackDeleted",
		},
		{
			Value:       "update_succeeded",
			Description: "Trigger a webhook when a stack update succeeds.",
			Name:        "UpdateSucceeded",
		},
		{
			Value:       "update_failed",
			Description: "Trigger a webhook when a stack update fails.",
			Name:        "UpdateFailed",
		},
		{
			Value:       "preview_succeeded",
			Description: "Trigger a webhook when a stack preview succeeds.",
			Name:        "PreviewSucceeded",
		},
		{
			Value:       "preview_failed",
			Description: "Trigger a webhook when a stack preview fails.",
			Name:        "PreviewFailed",
		},
		{
			Value:       "destroy_succeeded",
			Description: "Trigger a webhook when a stack destroy succeeds.",
			Name:        "DestroySucceeded",
		},
		{
			Value:       "destroy_failed",
			Description: "Trigger a webhook when a stack destroy fails.",
			Name:        "DestroyFailed",
		},
		{
			Value:       "refresh_succeeded",
			Description: "Trigger a webhook when a stack refresh succeeds.",
			Name:        "RefreshSucceeded",
		},
		{
			Value:       "refresh_failed",
			Description: "Trigger a webhook when a stack refresh fails.",
			Name:        "RefreshFailed",
		},
		{
			Value:       "deployment_queued",
			Description: "Trigger a webhook when a deployment is queued.",
			Name:        "DeploymentQueued",
		},
		{
			Value:       "deployment_started",
			Description: "Trigger a webhook when a deployment starts running.",
			Name:        "DeploymentStarted",
		},
		{
			Value:       "deployment_succeeded",
			Description: "Trigger a webhook when a deployment succeeds.",
			Name:        "DeploymentSucceeded",
		},
		{
			Value:       "deployment_failed",
			Description: "Trigger a webhook when a deployment fails.",
			Name:        "DeploymentFailed",
		},
	}
}

func (*Webhook) Check(
	ctx p.Context, name string, _ resource.PropertyMap, uncheckedInputs resource.PropertyMap,
) (WebhookInput, []p.CheckFailure, error) {
	inputs, failures, err := infer.DefaultCheck[WebhookInput](uncheckedInputs)
	if len(failures) > 0 || err != nil {
		return inputs, failures, nil
	}

	stackWebhookError := "projectName and stackName must both be specified for stack webhooks, or both unspecified for org webhooks"
	if inputs.ProjectName == nil && inputs.StackName != nil {
		failures = append(failures, p.CheckFailure{
			Reason:   stackWebhookError,
			Property: "projectName",
		})
	}
	if inputs.ProjectName != nil && inputs.StackName == nil {
		failures = append(failures, p.CheckFailure{
			Reason:   stackWebhookError,
			Property: "stackName",
		})
	}

	return inputs, failures, nil
}

func (*Webhook) Create(
	ctx p.Context, name string, input WebhookInput, preview bool,
) (string, WebhookState, error) {
	if preview {
		return "", WebhookState{WebhookInput: input}, nil
	}

	webhook, err := GetConfig(ctx).Client.CreateWebhook(ctx, input.asRequest())
	if err != nil {
		return "", WebhookState{}, err
	}

	var hookID string
	if input.ProjectName != nil && input.StackName != nil {
		hookID = fmt.Sprintf("%s/%s/%s/%s", input.OrganizationName, *input.ProjectName, *input.StackName,
			webhook.Name)
	} else {
		hookID = fmt.Sprintf("%s/%s", input.OrganizationName, webhook.Name)
	}

	return hookID, WebhookState{
		WebhookInput: input,
		Name:         webhook.Name,
		Format:       webhook.Format,
	}, nil
}

func (*Webhook) Update(
	ctx p.Context, id string, state WebhookState, news WebhookInput, preview bool,
) (WebhookState, error) {
	if preview {
		return WebhookState{WebhookInput: news}, nil
	}

	contract.Assertf(state.OrganizationName == news.OrganizationName,
		"We should have done a replace here if OrganizationName changed")

	hookID, err := splitWebhookID(id)
	if err != nil {
		return WebhookState{}, fmt.Errorf("invalid resource id: %v", err)
	}

	err = GetConfig(ctx).Client.UpdateWebhook(ctx, pulumiapi.UpdateWebhookRequest{
		WebhookRequest: news.asRequest(),
		Name:           hookID.webhookName,
	})
	if err != nil {
		return WebhookState{}, err
	}

	// We need to perform another GET because the user might not have set Format but
	// the service will have.
	//
	// This is because Format is optional as an input but required as an output.
	return getWebhook(ctx, hookID)
}

func (*Webhook) Delete(ctx p.Context, id string, props WebhookState) error {
	hookID, err := splitWebhookID(id)
	if err != nil {
		return err
	}

	return GetConfig(ctx).Client.DeleteWebhook(ctx, hookID.organizationName,
		hookID.projectName, hookID.stackName, hookID.webhookName)
}

func (*Webhook) Read(
	ctx p.Context, id string, _ WebhookInput, _ WebhookState,
) (string, WebhookInput, WebhookState, error) {
	hookID, err := splitWebhookID(id)
	if err != nil {
		return "", WebhookInput{}, WebhookState{}, err
	}

	state, err := getWebhook(ctx, hookID)
	return id, state.WebhookInput, state, nil
}

func getWebhook(ctx p.Context, hookID webhookID) (WebhookState, error) {
	webhook, err := GetConfig(ctx).Client.GetWebhook(context.Background(),
		hookID.organizationName, hookID.projectName, hookID.stackName, hookID.webhookName)
	if err != nil {
		return WebhookState{}, err
	}

	input := WebhookInput{
		Active:           webhook.Active,
		DisplayName:      webhook.DisplayName,
		PayloadUrl:       webhook.PayloadUrl,
		Secret:           webhook.Secret,
		OrganizationName: hookID.organizationName,
		ProjectName:      hookID.projectName,
		StackName:        hookID.stackName,
		Format:           &webhook.Format,
		Filters: sliceMap(webhook.Filters, func(v string) WebhookFilters {
			// TODO: Validate that each filter is OneOf(WebhookFilters.Values)
			return WebhookFilters(v)
		}),
	}

	return WebhookState{
		WebhookInput: input,
		Name:         hookID.webhookName,
		Format:       webhook.Format,
	}, nil
}

func sliceMap[S ~[]E, E any, O any](slice S, f func(E) O) []O {
	result := make([]O, len(slice))
	for i, v := range slice {
		result[i] = f(v)
	}
	return result
}

func splitWebhookID(id string) (webhookID, error) {
	// format: organization/project/stack/webhookName (stack webhook) or organization/webhookName (org webhook)
	s := strings.Split(id, "/")
	switch len(s) {
	case 2:
		return webhookID{
			organizationName: s[0],
			webhookName:      s[1],
		}, nil
	case 4:
		return webhookID{
			organizationName: s[0],
			projectName:      &s[1],
			stackName:        &s[2],
			webhookName:      s[3],
		}, nil
	default:
		return webhookID{}, fmt.Errorf("%q is not a valid webhook ID", id)
	}
}

type webhookID struct {
	organizationName string
	projectName      *string
	stackName        *string
	webhookName      string
}

func (input WebhookInput) asRequest() pulumiapi.WebhookRequest {
	filters := make([]string, len(input.Filters))
	for i, f := range input.Filters {
		filters[i] = string(f)
	}

	return pulumiapi.WebhookRequest{
		OrganizationName: input.OrganizationName,
		ProjectName:      input.ProjectName,
		StackName:        input.StackName,
		DisplayName:      input.DisplayName,
		PayloadURL:       input.PayloadUrl,
		Secret:           input.Secret,
		Active:           input.Active,
		Format:           input.Format,
		Filters:          filters,
	}
}
